{
 cells [
  {
   cell_type code,
   execution_count null,
   id d540022f-1d6d-4e02-94e5-b05b6bd474f7,
   metadata {},
   outputs [],
   source [
    import streamlit as stn,
    import pandas as pdn,
    import numpy as npn,
    import ren,
    from scipy.optimize import curve_fitn,
    import plotly.express as pxn,
    import ion,
    n,
    st.title(LegendPlex Analyzer — Interactive 4PL5PL)n,
    n,
    # ---------- 1. Upload & clean ----------n,
    uploaded = st.file_uploader(Upload FlowJo export (.csv or .xlsx), type=[csv, xlsx])n,
    n,
    def load_file(file)n,
        return pd.read_csv(file) if file.name.endswith(.csv) else pd.read_excel(file)n,
    n,
    def clean_colnames(df)n,
        df.columns = df.columns.astype(str)n,
        df.rename(columns={df.columns[0] ID}, inplace=True)n,
        def extract_marker(c)n,
            m = re.search(r.(.)s, c)n,
            return m.group(1).strip() if m else cn,
        df.columns = [extract_marker(c) for c in df.columns]n,
        return dfn,
    n,
    if uploadedn,
        df = clean_colnames(load_file(uploaded))n,
        st.success(✅ Columns cleaned successfully.)n,
        st.dataframe(df.head())n,
    n,
        # ---------- 2. Detect standards ----------n,
        std_rows = df[df[ID].str.contains(Standard, case=False, na=False)]n,
        if std_rows.emptyn,
            st.error(⚠️ No standards detected. Make sure IDs contain 'Standard'.)n,
            st.stop()n,
        st.info(fDetected {len(std_rows)} standards.)n,
    n,
        # ---------- 3. User inputs ----------n,
        dilution_factor = st.number_input(Serial dilution factor (e.g., 3), min_value=1.0, value=3.0)n,
        analytes = [c for c in df.columns if c not in [ID, WELL ID]]n,
        st.markdown(### Enter top standard concentrations (from CoA, ngmL))n,
        top_conc = {a st.number_input(f{a}, min_value=0.001, value=10.0) for a in analytes}n,
    n,
        st.markdown(### Assign dilution factors to sample IDs (optional))n,
        sample_ids = df.loc[~df[ID].str.contains(Standard, case=False, na=False), ID].unique()n,
        sample_dilutions = {sid st.number_input(f{sid} dilution factor, min_value=1.0, value=1.0)n,
                            for sid in sample_ids}n,
    n,
        fit_type = st.radio(Choose curve model, [4PL, 5PL])n,
        proceed = st.button(Run analysis)n,
    n,
        if proceedn,
            # ---------- 4. Prepare standard conc table ----------n,
            conc_pg = {a [top_conc[a]  1000] for a in analytes}n,
            for _ in range(1, len(std_rows))n,
                for a in analytesn,
                    conc_pg[a].append(conc_pg[a][-1]  dilution_factor)n,
            reps = pd.DataFrame(conc_pg)n,
            reps.insert(0, ID, std_rows[ID].values)n,
    n,
            # ---------- 5. QC ----------n,
            if df[analytes].isnull().any().any()n,
                st.error(Missing or invalid MFI values detected.)n,
                st.stop()n,
            st.success(✅ Standard MFI values OK.)n,
    n,
            # ---------- 6. Define models ----------n,
            def fourPL(x, A, B, EC50, n)n,
                return A + (B - A)  (1 + np.exp(n  (x - EC50)))n,
            def fivePL(x, A, B, EC50, n, s)n,
                return A + (B - A)  ((1 + np.exp(n  (x - EC50)))  s)n,
    n,
            # ---------- 7. Fit curves & plot ----------n,
            fit_results, plots = {}, []n,
            for a in analytesn,
                tryn,
                    x = np.log10(reps[a].astype(float))n,
                    y = np.log10(std_rows[a].astype(float))n,
                    if fit_type == 4PLn,
                        popt, _ = curve_fit(fourPL, x, y, maxfev=10000)n,
                        y_fit = fourPL(x, popt)n,
                    elsen,
                        popt, _ = curve_fit(fivePL, x, y, p0=[min(y), max(y), np.median(x), -1, 1], maxfev=10000)n,
                        y_fit = fivePL(x, popt)n,
    n,
                    # R²n,
                    r2 = 1 - np.sum((y - y_fit)  2)  np.sum((y - np.mean(y))  2)n,
                    fit_results[a] = {params popt, r2 r2}n,
    n,
                    # Plotn,
                    x_fit = np.linspace(min(x), max(x), 100)n,
                    y_curve = fourPL(x_fit, popt) if fit_type == 4PL else fivePL(x_fit, popt)n,
                    fig = px.scatter(x=x, y=y, title=f{a} — {fit_type} Fit (R²={r2.3f}),n,
                                     labels={x log10(Conc), y log10(MFI)})n,
                    fig.add_scatter(x=x_fit, y=y_curve, mode=lines, name=Fit, line=dict(color=orange))n,
                    if r2  0.95n,
                        st.warning(f⚠️ {a} R²={r2.3f}, curve may be poor.)n,
                    plots.append(fig)n,
                except Exception as en,
                    st.warning(f⚠️ Fit failed for {a} {e})n,
    n,
            st.success(✅ Curve fitting complete.)n,
            for fig in plotsn,
                st.plotly_chart(fig, use_container_width=True)n,
    n,
            # ---------- 8. Interpolate samples ----------n,
            samples = df.loc[~df[ID].str.contains(Standard, case=False, na=False)].copy()n,
            for a in analytesn,
                if a not in fit_resultsn,
                    continuen,
                popt = fit_results[a][params]n,
                y = np.log10(samples[a].astype(float))n,
                tryn,
                    if fit_type == 4PLn,
                        A, B, EC50, n = poptn,
                        x_pred = EC50 + (1n)  np.log((B - A)  (y - A) - 1)n,
                    elsen,
                        A, B, EC50, n, s = poptn,
                        x_pred = EC50 + (1n)  np.log((B - A)(1s)  (y - A)(1s) - 1)n,
                    samples[f{a}_conc_pgml] = 10  x_pred  samples[ID].map(sample_dilutions)n,
                except Exceptionn,
                    samples[f{a}_conc_pgml] = np.nann,
    n,
            # ---------- 9. Export ----------n,
            st.markdown(### Export results)n,
            output_name = st.text_input(Output file name (no extension), value=LegendPlex_results)n,
    n,
            long_df = samples.melt(id_vars=[ID], var_name=Analyte_or_MFI, value_name=Value)n,
            wide_df = samples.copy()n,
    n,
            output = io.BytesIO()n,
            with pd.ExcelWriter(output, engine=openpyxl) as writern,
                long_df.to_excel(writer, index=False, sheet_name=Long_Format)n,
                wide_df.to_excel(writer, index=False, sheet_name=Wide_Format)n,
            output.seek(0)n,
    n,
            st.download_button(n,
                label=⬇️ Download .xlsx file,n,
                data=output,n,
                file_name=f{output_name}.xlsx,n,
                mime=applicationvnd.openxmlformats-officedocument.spreadsheetml.sheetn,
            )n,
    elsen,
        st.info(Please upload a FlowJo export to begin.)n
   ]
  }
 ],
 metadata {
  kernelspec {
   display_name Python [conda envood],
   language python,
   name conda-env-ood-py
  },
  language_info {
   codemirror_mode {
    name ipython,
    version 3
   },
   file_extension .py,
   mimetype textx-python,
   name python,
   nbconvert_exporter python,
   pygments_lexer ipython3,
   version 3.12.0
  }
 },
 nbformat 4,
 nbformat_minor 5
}
