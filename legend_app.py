{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d540022f-1d6d-4e02-94e5-b05b6bd474f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import re\n",
    "from scipy.optimize import curve_fit\n",
    "import plotly.express as px\n",
    "import io\n",
    "\n",
    "st.title(\"LegendPlex Analyzer — Interactive 4PL/5PL\")\n",
    "\n",
    "# ---------- 1. Upload & clean ----------\n",
    "uploaded = st.file_uploader(\"Upload FlowJo export (.csv or .xlsx)\", type=[\"csv\", \"xlsx\"])\n",
    "\n",
    "def load_file(file):\n",
    "    return pd.read_csv(file) if file.name.endswith(\".csv\") else pd.read_excel(file)\n",
    "\n",
    "def clean_colnames(df):\n",
    "    df.columns = df.columns.astype(str)\n",
    "    df.rename(columns={df.columns[0]: \"ID\"}, inplace=True)\n",
    "    def extract_marker(c):\n",
    "        m = re.search(r\".*?/(.*?)\\s*\\|\", c)\n",
    "        return m.group(1).strip() if m else c\n",
    "    df.columns = [extract_marker(c) for c in df.columns]\n",
    "    return df\n",
    "\n",
    "if uploaded:\n",
    "    df = clean_colnames(load_file(uploaded))\n",
    "    st.success(\"✅ Columns cleaned successfully.\")\n",
    "    st.dataframe(df.head())\n",
    "\n",
    "    # ---------- 2. Detect standards ----------\n",
    "    std_rows = df[df[\"ID\"].str.contains(\"Standard\", case=False, na=False)]\n",
    "    if std_rows.empty:\n",
    "        st.error(\"⚠️ No standards detected. Make sure IDs contain 'Standard'.\")\n",
    "        st.stop()\n",
    "    st.info(f\"Detected {len(std_rows)} standards.\")\n",
    "\n",
    "    # ---------- 3. User inputs ----------\n",
    "    dilution_factor = st.number_input(\"Serial dilution factor (e.g., 3):\", min_value=1.0, value=3.0)\n",
    "    analytes = [c for c in df.columns if c not in [\"ID\", \"WELL ID\"]]\n",
    "    st.markdown(\"### Enter top standard concentrations (from CoA, ng/mL):\")\n",
    "    top_conc = {a: st.number_input(f\"{a}:\", min_value=0.001, value=10.0) for a in analytes}\n",
    "\n",
    "    st.markdown(\"### Assign dilution factors to sample IDs (optional):\")\n",
    "    sample_ids = df.loc[~df[\"ID\"].str.contains(\"Standard\", case=False, na=False), \"ID\"].unique()\n",
    "    sample_dilutions = {sid: st.number_input(f\"{sid} dilution factor:\", min_value=1.0, value=1.0)\n",
    "                        for sid in sample_ids}\n",
    "\n",
    "    fit_type = st.radio(\"Choose curve model:\", [\"4PL\", \"5PL\"])\n",
    "    proceed = st.button(\"Run analysis\")\n",
    "\n",
    "    if proceed:\n",
    "        # ---------- 4. Prepare standard conc table ----------\n",
    "        conc_pg = {a: [top_conc[a] * 1000] for a in analytes}\n",
    "        for _ in range(1, len(std_rows)):\n",
    "            for a in analytes:\n",
    "                conc_pg[a].append(conc_pg[a][-1] / dilution_factor)\n",
    "        reps = pd.DataFrame(conc_pg)\n",
    "        reps.insert(0, \"ID\", std_rows[\"ID\"].values)\n",
    "\n",
    "        # ---------- 5. QC ----------\n",
    "        if df[analytes].isnull().any().any():\n",
    "            st.error(\"Missing or invalid MFI values detected.\")\n",
    "            st.stop()\n",
    "        st.success(\"✅ Standard MFI values OK.\")\n",
    "\n",
    "        # ---------- 6. Define models ----------\n",
    "        def fourPL(x, A, B, EC50, n):\n",
    "            return A + (B - A) / (1 + np.exp(n * (x - EC50)))\n",
    "        def fivePL(x, A, B, EC50, n, s):\n",
    "            return A + (B - A) / ((1 + np.exp(n * (x - EC50))) ** s)\n",
    "\n",
    "        # ---------- 7. Fit curves & plot ----------\n",
    "        fit_results, plots = {}, []\n",
    "        for a in analytes:\n",
    "            try:\n",
    "                x = np.log10(reps[a].astype(float))\n",
    "                y = np.log10(std_rows[a].astype(float))\n",
    "                if fit_type == \"4PL\":\n",
    "                    popt, _ = curve_fit(fourPL, x, y, maxfev=10000)\n",
    "                    y_fit = fourPL(x, *popt)\n",
    "                else:\n",
    "                    popt, _ = curve_fit(fivePL, x, y, p0=[min(y), max(y), np.median(x), -1, 1], maxfev=10000)\n",
    "                    y_fit = fivePL(x, *popt)\n",
    "\n",
    "                # R²\n",
    "                r2 = 1 - np.sum((y - y_fit) ** 2) / np.sum((y - np.mean(y)) ** 2)\n",
    "                fit_results[a] = {\"params\": popt, \"r2\": r2}\n",
    "\n",
    "                # Plot\n",
    "                x_fit = np.linspace(min(x), max(x), 100)\n",
    "                y_curve = fourPL(x_fit, *popt) if fit_type == \"4PL\" else fivePL(x_fit, *popt)\n",
    "                fig = px.scatter(x=x, y=y, title=f\"{a} — {fit_type} Fit (R²={r2:.3f})\",\n",
    "                                 labels={\"x\": \"log10(Conc)\", \"y\": \"log10(MFI)\"})\n",
    "                fig.add_scatter(x=x_fit, y=y_curve, mode=\"lines\", name=\"Fit\", line=dict(color=\"orange\"))\n",
    "                if r2 < 0.95:\n",
    "                    st.warning(f\"⚠️ {a}: R²={r2:.3f}, curve may be poor.\")\n",
    "                plots.append(fig)\n",
    "            except Exception as e:\n",
    "                st.warning(f\"⚠️ Fit failed for {a}: {e}\")\n",
    "\n",
    "        st.success(\"✅ Curve fitting complete.\")\n",
    "        for fig in plots:\n",
    "            st.plotly_chart(fig, use_container_width=True)\n",
    "\n",
    "        # ---------- 8. Interpolate samples ----------\n",
    "        samples = df.loc[~df[\"ID\"].str.contains(\"Standard\", case=False, na=False)].copy()\n",
    "        for a in analytes:\n",
    "            if a not in fit_results:\n",
    "                continue\n",
    "            popt = fit_results[a][\"params\"]\n",
    "            y = np.log10(samples[a].astype(float))\n",
    "            try:\n",
    "                if fit_type == \"4PL\":\n",
    "                    A, B, EC50, n = popt\n",
    "                    x_pred = EC50 + (1/n) * np.log((B - A) / (y - A) - 1)\n",
    "                else:\n",
    "                    A, B, EC50, n, s = popt\n",
    "                    x_pred = EC50 + (1/n) * np.log((B - A)**(1/s) / (y - A)**(1/s) - 1)\n",
    "                samples[f\"{a}_conc_pgml\"] = 10 ** x_pred * samples[\"ID\"].map(sample_dilutions)\n",
    "            except Exception:\n",
    "                samples[f\"{a}_conc_pgml\"] = np.nan\n",
    "\n",
    "        # ---------- 9. Export ----------\n",
    "        st.markdown(\"### Export results\")\n",
    "        output_name = st.text_input(\"Output file name (no extension):\", value=\"LegendPlex_results\")\n",
    "\n",
    "        long_df = samples.melt(id_vars=[\"ID\"], var_name=\"Analyte_or_MFI\", value_name=\"Value\")\n",
    "        wide_df = samples.copy()\n",
    "\n",
    "        output = io.BytesIO()\n",
    "        with pd.ExcelWriter(output, engine=\"openpyxl\") as writer:\n",
    "            long_df.to_excel(writer, index=False, sheet_name=\"Long_Format\")\n",
    "            wide_df.to_excel(writer, index=False, sheet_name=\"Wide_Format\")\n",
    "        output.seek(0)\n",
    "\n",
    "        st.download_button(\n",
    "            label=\"⬇️ Download .xlsx file\",\n",
    "            data=output,\n",
    "            file_name=f\"{output_name}.xlsx\",\n",
    "            mime=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n",
    "        )\n",
    "else:\n",
    "    st.info(\"Please upload a FlowJo export to begin.\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:ood]",
   "language": "python",
   "name": "conda-env-ood-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
